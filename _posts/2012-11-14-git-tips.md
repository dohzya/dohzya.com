---
title:  Git tips
tagline: Petites infos utiles
author: Étienne VALLETTE d'OSIA
language: French
layout: post
category : article
tags : [git]
---

* TOC
{:toc}

{% include JB/setup %}

# Git tips

Je vais fournir ici quelques conseils et explications sur (ce que j'ai compris de) Git. Il s'agit bien évidemment de mon point de vue, donc il n'est pas exclu que certains ne soient pas d'accord avec ce que je vais écrire.

Je ne compte pas faire une introduction à Git — d'autant qu'il existe beaucoup de très bonnes références, par exemple le [git book][http://git-scm.com/book].

Mon but n'est pas non plus de vous fournir des raccourcis pour vous faire gagner du temps. Ce que je décris sont des **bonnes pratiques pour vous éviter des mauvaises surprises**, pour _vous éviter de perdre du temps_. Vous voyez la nuance ? :-)

Bien entendu, il existe plusieurs manières de réaliser chacune des actions que je vais montrer. Je présenterai celles qui me semblent les meilleures, mais rien ne vous empêche — au contraire ! — d'explorer les autres et de les comparer.

Bon, maintenant que tout cela est dit, commençons !

## Quelques idées sur la manière de travailler avec Git

Ce n'est pas tout de connaitre les commandes, il faut aussi savoir _quand_ utiliser _quoi_. Quand préférer un `merge` à un `rebase`, quand créer de nouvelles branches, etc.

Je place donc dans cette section les idées que j'ai dégoté (ou inventé avec mes petits m… ha bah non).

### Merge _fast-forward_ ou non ?

Pour commencer, petite présentation de ce que veut dire « fast-forward ». Pour commencer, vous pouvez aller voir [ce lien](http://365git.tumblr.com/post/504140728/fast-forward-merge). L'idée est de modifier uniquement la référence de la branche, _sans créer un commit de merge_. Cela n'est donc possible que si la branche à merger est basée sur la branche principale (le dernier commit de la branche sur laquelle on merge doit être l'unique parent direct du premier commit de la branche à merger).

Il y a 3 modes pour la commande `merge` :

`--ff` (par défaut)
:	un merge _fast-forward_ est effectué si possible. Sinon un merge normal est utilisé.

`--ff-only`
:	On demande ici à ce que seul un merge _fast-forward_ soit effectué. Si les conditions ne le permettent pas, la commande ne fait rien.

`--no-ff`
:	On demande ici à ce qu'un un merge normal soit effectué, même si les conditions permettent de réaliser un merge _fast-forward_.

Dans les faits, vous devriez rarement utiliser `--ff` : soit vous effectuez un merge _fast-forward_ pour vous synchroniser (là où vous auriez tout aussi bien pu utiliser un rebase), soit vous souhaitez réellement merger une branche (par exemple la branche sur laquelle vous développiez vous nouvelle fonctionnalité) et en ce cas vous vous tournez vers un merge non _fast-forward_. La première option est donc à voir comme un raccourci : lorsque je _sais_ que l'option `--ff` va faire ce que je veux, alors je ne suis pas forcé de préciser le comportement via les option.

### Commiter puis réfléchir

Information logique mais importante, donc je la marque pour que ce soir clair : Git ne gère pas des fichiers modifiés mais des commits. Donc si vous voulez sauvegarder des modifications importantes, commitez-les.

Je me permets de me la jouer Captain Obvious car j'ai vu plusieurs fois des personnes qui laissaient des modifications non commités pendant des jours, voire des semaines, dans leur dépôt, car « c'est pas encore fini alors je vais pas le commiter ».

Que ce soit clair : ce raisonnement est complètement faux. La base même de Git est qu'il est distribué : chacun à son propre dépôt, que seul lui peut voir. Il est donc tout à faire possible — en fait c'est _normal_ — d'avoir des commits dans son dépôt qui n'ont pas été pushés dans des dépôts commun.

Par exemple, lorsque vous travaillez sur votre branche perso, vous créez plein de petits commits, puis les mergez à la branche principale et ne les pushez qu'à partir de ce moment là. Ainsi vous avez pu avoir tous les avantages de Git  sans pour autant ennuyer vos collègues.

De même, il est tout à faire normal de créer des commits temporaires (que j'appelle WIP), puis de les supprimer plus tard tout en conservant les modifications.

*[WIP]: Work In Progress

Prenons un exemple : imaginons que je sois sur ma branche « `feature/export` », avec des modifications en cours. Un élément déclencheur (on me demande quelque chose, je viens d'y penser, le grand Ordonnanceur me parle, ou que sais-je) fait que je dois changer de branche (par exemple pour aller sur `master` afin de tester quelque chose).

Voici 2 solutions possibles pour réaliser cela sans risque :

#### Commit « WIP »

Git permet de commiter facilement (par exemple via la commande « `git commit -am WIP` ») mais aussi d'annuler un commit très simplement, via la commande `reset`.

{% highlight bash %}
 # Sauvegarde de l'état courant
git add . && git commit -m WIP
 # Changement de branche
git checkout master
 # Je fais mes petites affaires
[…]
 # Je reviens sur ma branche, donc sur le commit « WIP »
git checkout feature/export
 # Je restaure l'état, en annulant le commit SANS CHANGER LES FICHIERS
git reset HEAD~1
 # Je peux continuer ce que je faisais
{% endhighlight %}

Le commit WIP ne devrait pas être pushé sur un dépôt commun, mais peut être envoyé à un dépôt personnel si vous en avez un (un dépôt distant que seul vous utilisez, afin d'avoir une copie de sauvegarde).

Étant donné que l'état est sauvegarder dans un commit, il sera possible de ne retrouver (si le besoin s'en fait sentir) dans le [`reflog`](#reflog).

#### Stash

Git fourni un outil dédié à ce genre de cas : `git stash`.

Il permet de sauvegarder facilement toutes les modifications actuelles dans un `stash`, une sorte de commit capable de préserver l'[`index`](#index).

{% highlight bash %}
 # Sauvegarde de l'état courant
git stash
 # Changement de branche
git checkout master
 # Je fais mes petites affaires
[…]
 # Je reviens sur ma branche, donc sur le commit « WIP »
git checkout feature/export
 # Je restaure l'état, en annulant le commit SANS CHANGER LES FICHIERS
git stash pop
 # Je peux continuer ce que je faisais
{% endhighlight %}

Contrairement aux commit « normaux », le `stash` n'est pas conservé dans le [`reflog`](#reflog).

En soit le `stash` est un très bon outil, mais j'ai vu beaucoup de mauvaises utilisations donc je préfère vous mettre en garde dès maintenant : **`git stash` ne remplace en aucun cas les branches**.

Lorsque vous démarrez quelque chose de complexe, créez-vous une branche dédiée, et sauvegardez dedans (via un commit WIP ou un `stash`), mais ne vous contentez surtout pas d'avoir une dizaines de stash pointant sur votre branche `master` : vous vous y perdrez à coup sûr (et aurez raté toute la puissance de Git).

Si vous n'êtes pas sûr de votre manière de travailler, je vous conseille de ne pas utiliser `git stash`, jusqu'à ce que vous vous sentiez plus à l'aise avec les branches et le reste.


### Qui contrôle le futur contrôle le passé

Avec des outils comme `git rebase -i` il vous est possible de réécrire (un pan de) l'historique de votre projet. Ce qu'il ne faut pas oublier, c'est que — contrairement aux merges — cette opération supprime l'ancienne version de l'historique, vous empêchant de vous y référer plus tard en cas de problème.

Gardez ceci en tête lorsque vous vous lancerez dans un gros rebase : plus vous devez corriger de conflits, plus vous vous éloignez de la véritable forme de votre historique… et donc potentiellement de votre code final ! Je vous conseille donc vivement de relancer vos tests à la fin d'un rebase, comme si vous veniez d'effectuer un commit.

Petite note : je parle ici de modification d'historique, mais c'est un réalité un abus de langage : l'historique a en réalité été dupliqué. Il est donc tout à fait possible de stocker le SHA1 du commit (en bout de la branche) qu'on va rebaser[^marquercommit]. Cela permet, à la fin de l'opération, de comparer l'ancien historique et le nouveau. Sachez que cette astuce est — en quelque sorte — offerte par Git sous la forme de sa référence magique `ORIG_HEAD`.

[^marquercommit]: En le notant sur une feuille ou en créant une branche par exemple.

### Le reflog {#reflog}

Le reflog est un super outil, destiné à être oublié jusqu'à ce qu'il vous sauve la vie.

Le modèle de Git empêche toute modification des objets existants, donc toutes les opérations que vous effectuerez consisteront en la _création_ de nouveaux objets, avec (ou non) modification des références existantes.

Les anciens objets sont donc toujours intacts, mais plus personne ne les références et ils seront donc supprimés par Git lors du prochain `git gc` (ne vous en souciez pas, Git l'appellera automatiquement de temps en temps). De plus, elle sont (par défaut) conservée au minimum 30 jours. C'est à dire que si vous faites « `git commit --amend` », l'ancienne version du commit existera toujours dans le système dans 30 jours.

Cependant à quoi bon avoir des objets dans le système si personne ne les référence ? Et bien c'est ici que le reflog entre en scène : il liste tous les changements effectués sur des commits. Vous commitez, c'est dans le reflog. Vous faite un rebase, c'est dans le reflog. Vous changez de branche, c'est dans le reflog. Vous faites un `git reset <ref>`, c'est dans le reflog…

Il y a 2 méthodes pour visualiser le reflog : « `git reflog` » et « `git log -g` ».

### Les branches c'est pas sale

Rien de nouveau ici si ce n'est une petite note : n'ayez pas peur d'avoir des merges dans votre historique : c'est fait pour. Git n'est pas perturbé par les branches, de même qu'il vous permet de masquer les commits de merge si vous voulez. Donc ne vous forcez surtout pas à ne pas avoir de merges, ni à avoir un historique parfait : ce qui compte c'est le contenu.

### `git add`

Je vous ai parlé de l'`index`, qui contient les modifications que Git inclura dans le prochain commit.

La commande pour cela est `git add`, mais ses options lui confèrent beaucoup plus de finesse :

- `--edit`
:	Affiche le `diff` complet de tous les changements vus par Git. Vous pouvez ainsi y enlever les parties non désirées et/ou modifier manuellement certains bouts.

- `--patch`
:	Affiche le `diff` des changements, mais bouts par bouts. Vous pouvez ainsi n'inclure que les (parties de) fichiers qui vous intéresse, voire lancer un éditeur pour les modifier (à la `--edit`)

- `--edit`
:	Affiche un menu permettant de voir l'état des fichiers, en inclure, en utilisant les 2 options précédentes ou non.

Bref, il y a de quoi faire les choses bien, alors c'est vraiment du gâchis que de se cantonner à « `git commit -a` »…

## Oubliez SVN.

Voilà, tout est dit. N'y voyez pas une critique sauvage de cet outil, juste un conseil pour éviter de vous prendre les pieds dans le tapis.

J'ai vu beaucoup de personnes passer de Subversion à Git, et la plupart tentent de convertir les commandes `svn` en commandes `git`. Pas de bol : cette approche ne fonctionne pas.

**Git n'est pas Subversion, alors arrêtez de l'utiliser de la même manière !**

Git manipule certains concepts qui sont (pour l'instant ?) étrangers à Subversion. Cela lui confère plus de puissance (en tout cas là dessus) mais le rend aussi _plus complexe_. Vous ne pouvez pas masquer cette complexité dernière des scripts ou des alias : vous engrangerez les problèmes incompréhensibles…

En fait, le plus simple c'est de _désapprendre_ Subversion. Oubliez ce que vous savez, et apprenez la gestion de sources vue par Git.

Voici 3 exemples pour illustrer mes propos :

### L'index {#index}

L'index est un espace dans lequel Git stocke les modifications qui seront incluses dans le prochain commit.

Le but est de permettre de manipuler finement les modifications enregistrer. Il est possible de modifier à la volée une modifications à enregistrer (très utile pour ne commiter qu'une partie des modifications, ou bien pour séparer un ensemble de changements en plusieurs commits) voire — pour ceux que ça amuse — d'enregistrer l'index pour le réutiliser par la suite.

L'utilisateur de Git est donc forcé de peupler son index avant de commiter.

Note : J'ai cru comprendre que les développeurs de Subversion songent à lui en fournir un aussi. Mais bon, on s'en fout un peu en fait, ce qui compte c'est la manière dont _vous_ l'utiliser _maintenant_ ;-)

### Les branches

Bien évidemment, Subversion aussi possède le concept de branches, et ce depuis bien plus longtemps que Git (étant donné qu'il est plus vieux :p), cependant la manière de les appréhender est très différente.

Alors, je ne vais pas rentrer dans les détails ici, mais sachez juste qu'il est parfaitement normal — et très courant — de créer une branche avec Git et de la supprimer plus tard. Le modèle rend les branches très légères et totalement décorrélées des commits. Par exemple vous pouvez supprimer une branche que vous venez de merger : vous conserverez l'historique de tous les commits effectués dans cette branche.

Tiens j'en profite pour glisser un avantage de Subversion, histoire de : il permet de réaliser un même commit sur plusieurs branches d'un coup. Git quant à lui forcera à créer un commit sur une branche, puis à le copier (ou merger) dans les autres. Et toc !

Je m'étendrai sur les branches [plus tard](#workflow), mais sachez juste qu'une utilisation normale de Git n'est _pas_ cantonnée à une branche principale. Il faut donc savoir les manipuler.

### La décentralisation

Le fer de lance des pro-Git.

Le concept est assez simple en fait : Git manipule des dépôts. Le dossier dans lequel vous travaillez, _contient_ un dépôt. Toutes les modifications que vous faites (commit, changement de branche, rebase, diff, …) sont effectuées au sein de ce dépôt _local_, et vous pouvez vous synchroniser avec d'autre dépôts (dits _distants_).

Ce concept n'est pas du tout présent chez Subversion, donc les comparer là dessus n'aurait aucun sens. Cependant notez que pour partager des modifications, un utilisateur Git ne peut pas se contenter de commiter, il doit aussi synchroniser son dépôt avec celui de ses collègues.

### Exemple

Voici une utilisation commune de Subversion :

{% highlight bash %}
 # 1. Je commit les fichiers qui m'intéresse
svn commit file1 file2

 # 2. Si le commit n'a pas marché, je merge puis recommit
svn merge
svn commit file1 file2

 # 3. Le collègue se met à jour
svn update
{% endhighlight %}

Soit 1 action pour envoyer sa modification, 1 action supplémentaire en cas de problème, et 1 action pour se mettre à jour.
  
Voici maintenant la version Git :

{% highlight bash %}
 # 1. J'ajoute les changements qui m'intéressent à l'index
git add file1 file2
 # 2. Je commit
git commit
 # 3. Je push sur un dépôt commun
git push origin master
 # 4. Si le push n'a pas marché, je me replace et repush
git rebase origin/master
git push origin master

 # 5. Le collègue se met à jour
git fetch
git rebase origin/master
{% endhighlight %}

Soit 3 actions pour envoyer sa modification, 1 action supplémentaire en cas de problème, et 2 actions pour se mettre à jour.

J'ai volontairement découpé les commandes, pour montrer tout ce qui doit être pensé pour Git.

### Conclusion

Si vous pensez qu'on peut traduire « `svn commit` » par « `git commit -a` »,  alors relisez ce chapitre, voire le [git book][http://git-scm.com/book].

Si vous pensez qu'on peut le traduire par « `git commit -a && git push` », c'est que vous êtes encore bloqué dans le modèle de Subversion. Continuer la lecture de cet article, et j'espère qu'à la fin (voire avant) vous aurez changé d'avis.

## Le cas de `git push` {#push}

`git push` est une des commandes Git utilisée quotidiennement, il convient donc de bien la connaître, pour en maîtriser la puissance et éviter les écueils.

Voici quelques conseils éviter les mauvaises surprises.

### La version longue c'est long… mais c'est bon (mais c'est long)

Tout le monde connaît le fameux « push-pull » pour se synchroniser avec le dépôt principal, mais « `git push<CR>` » n'est pas la vraie commande, c'est un raccourci.
Nous allons donc voir la vraie forme, ce qui vous permettra à la fois de mieux comprendre ce que vous faîtes… et d'utiliser les autres possibilités de cet outil.

### Oubliez « `git push --force …` »

L'option `--force` de `git push` force l'envoi de la référence, permettant d'écraser des branches distantes.

Cependant, cette option s'applique à tous les arguments de la commande.

Par exemple, je veux pousser d'un coup ma branche de développement (`feature/bla`) et la branche principale, dans laquelle j'ai ajouté un petit correctif. Si j'utilise « `git push --force origin master feature/bla` » alors je risque d'écraser la branche `master` par erreur. Dans le cas où ma branche `master` est dans un état étrange (par exemple si j'ai fait des rebases en pensant être dans ma branche de développement) alors le dépôt distant sera pollué.

Bien entendu, si j'avais utilisé « `git push --force` », j'aurais pu avoir le même résultat (cela dépend de la configuration), sauf qu'en plus je n'aurais pas su ce qui allait être pushé (à part pour ceux qui ont configuré leur Git et — le plus souvent — leur tracking en conséquence).

**Utilisez la syntaxe `+branch` à la place**, elle est plus puissante et donne plus de contrôle.

Dans mon exemple, si j'avais utilisé « `git push origin master +feature/bla` » alors seule la branche `feature/bla` aurait été poussée en force, permettant à Git de prévenir des éventuels cafouillages avec `master`.

Plus important : utiliser la syntaxe `+branch` force à nommer la branche à écraser, évidant le problème du « `git push --force <CR-oh-merde !>` ».

### Supprimez les branches distantes à l'aide « `git push <remote> :<ref>` »

Pour comprendre cette commande il faut connaître la forme complète de `git push`.

Voici un exemple : la commande « `git push origin master` » est un raccourci pour « `git push origin master:master` »[^completecomplete]. On spécifie la branche locale ainsi que la branche distante dans laquelle on pousse.

La commande « `git push <remote> :<ref>` » consiste donc à pousser _rien_ dans une branche distante… Il s'agit donc d'un effacement (à l'instar des « `mv <truc> /dev/null` » et Cie.

[^completecomplete]: Plus précisément : « `git push origin refs/heads/master:refs/heads/master` », mais on ne va pas chipotter.

### Utilisez le mode « simple » de git-push

Lorsque vous appelez `git push` sans fournir d'argument (volontairement ou non), le comportement adopté dépend de la configuration.

Voici les différents modes (actuels) :

- `nothing`
:	On ne fait rien (force à spécifier le dépôt et les références)

- `matching`
:	pousse les branches locales qui ont le même nom que des branches distantes

- `upstream`
:	pousse la branche actuelle sur sa branche trackée — Valeur par défaut de Git 1.x

- `simple`
:	pour la branche actuelle sur sa branche trackée _à condition que les deux aient le même nom_ — Ce sera le mode par défaut de Git 2.x

- `current`
:	pousse la branche actuelle sur la branche distante du même nom

Je vous conseille vivement d'opter dès maintenant pour la valeur `simple`. Pour ceci vous pouvez utiliser la commande suivante :

{% highlight bash %}
git config --global push.default simple
{% endhighlight %}

Voici un exemple d'erreur possible avec la valeur `upstream` :

{% highlight bash %}
 # Ici la branche master track la branche master du dépôt origin
git checkout master
 # On renomme master en develop, cela n'affecte pas le tracking
git branch -m develop
 # La branche develop sera poussée dans master
git push  # ⚠ ⇔ git push origin develop:master
{% endhighlight %}

J'ai parlé plusieurs fois de « tracking » dans cette section. Si vous ne savez pas ce que c'est, alors raison de plus pour utiliser le mode `simple` ! Mais ne vous en faites pas, [j'en parlerai plus tard](#tracking).

## `git pull` ou `git fetch` ?

On lit souvent « `git pull` », et beaucoup de gens risquent de *conseiller* d'utiliser cette commande pour se tenir à jour… Cependant cette commande n'est rien d'autre qu'une aide par dessus les vrais outils de synchronisation fournis par Git, et elle possède des limitations qu'il vaut mieux ne pas ignorer.

### La commande `git pull` est un raccourci, donc traitez-la comme telle {#pull}

La commande `git pull` est juste un raccourci pour `git fetch` + `git merge` (ou `git rebase`, selon votre configuration).

Je résume donc l'utilisation de cette commande

{% highlight bash %}
 # git pull origin master
git fetch origin
git merge origin/master
{% endhighlight %}

{% highlight bash %}
 # git pull --rebase origin master
git fetch origin
git rebase origin/master
{% endhighlight %}

Bon, encore une fois, il est possible d'omettre les arguments relatifs au dépôt et à la branche, mais dans ce cas le comportement dépendra de votre configuration. De plus, vous pouvez configurer `git pull` pour qu'il effectue un `--rebase` automatiquement.

Le point que je veux mettre en avant ici, c'est que vous faites 3 choses avec une seule commande :

1. mise à jour de la vue du dépôt distant, puis
2. `merge` des changements dans votre branche locale, ou
3. `rebase` de votre branche locale sur la distante.

Tout ça en une seule commande. Sérieusement, je pense que c'est une des pire manière d'appréhender Git : vous préservez le côté magique de l'outil.

Bien entendu, si vous êtes déjà à l'aise, il est tout à fait possible de l'utiliser de temps en temps comme raccourci. Cependant je ne peux que vous conseiller de vous familiariser avec `git fetch`.

### Apprenez à utiliser `git fetch` {#fetch}

Le problème que pose une utilisation exclusive de `git pull` est que _le seul moment où vous synchronisez votre vue des autres dépôts est celui où vous vous mettez à jour_. Donc comment faire lorsque vous travaillez sur une branche ? Vous lancez des `rebase` réguliers, histoire de ? Que faites-vous si vous avez plusieurs dépôts ?

Une réponse simple : utiliser la commande qui sert justement à mettre à jour votre vue du monde extérieur.

Vous pouvez lancer `git fetch` sans risque, elle ne cassera rien. À vrai dire vous pourriez mettre la mettre dans un `cron` pour qu'elle se lance toutes les minutes, voir coder un mécanisme basé sur les `hooks` pour qu'elle soit lancé automatiquement en cas de `push` sur un dépôt[^autofetch].

[^autofetch]: Bien sûr vous _pourriez_, mais ça ne serait pas une si bonne idée : évitez au maximum les _trucs_ qui se passent dans votre dos.

## Réécrire l'histoire {#rebase}

La commande `git rebase` fait parti des plus puissantes de Git[^rebase] : elle permet de replacer (ou re-baser pour être plus précis) une branche sur une autre.

Cette section ne va pas vous expliquer comment ça marche (pour ça je vous laisse 2 liens [ici](http://git-scm.com/book/en/Git-Branching-Rebasing) et [là](http://marklodato.github.com/visual-git-guide/index-en.html#rebase)), mais plutôt pour vous donner des petits tuyaux.

[^rebase]: Même si, au final, on peut reproduire son comportement manuellement.

### Rebase interactif {#rebase-interactive}

L'option `--interactive` (ou `-i` pour les intimes) demande à Git de vous afficher les commits qui vont être repris. Vous pouvez ainsi voir ce qui va se passer (très utile — _surtout_ quand vous pensez que non) voire modifier le comportement.

Git va lancer votre éditeur favori (sinon voyez la [configuration](#config)) pour vous présenter toutes les modifications qu'il compte faire.

Note: pour annuler le `rebase`, lorsque l'éditeur est lancé, effacez le fichier, _sauvegardez_ puis quitter. Pour plus d'infos, voir la sections sur [Git et les éditeurs](#editors).

Pour plus d'infos, n'oubliez pas la [section dédiée du git book](http://git-scm.com/book/en/Git-Tools-Rewriting-History) ni [`git help rebase`](http://git-scm.com/docs/git-rebase).

Comme toujours, une explication vous est fournie directement dans le fichier ouvert, dans les commentaires de fin.

L'idée est que vous verrez une ligne par commit, chaque ligne commençant par « pick ». Vous pouvez inverser l'ordre des lignes, voire en supprimer : cela aura pour effet de demander à Git d'inverser l'ordre des commits et d'en supprimer.

Vous pouvez aussi modifier le « pick ». Voici les différentes valeurs possibles (à l'heure où j'écris ces lignes) :

`pick`
:	reprend le commit tel quel

`reword`
:	reprend le commit et permet d'éditer le message

`edit`
:	reprend le commit et permet de l'éditer

`squash`
:	fusionne le commit avec le précédent, et permet d'éditer le message

`fixup`
:	pareil que squash, mais garde le message du premier commit

`exec`
:	exécute une commande

Les 3 premiers sont assez simples à comprendre : ils permettent de reprendre les commits et d'y apporter quelques modifications.

Les 2 suivants (`squash` et `fixup`) sont extrêmement intéressants, je vais les détailler dans [une prochaine section][autosquash].

### Notes

- Il est donc possible de modifier (ou changer l'ordre) des commits anciens, mais cela ne se fait pas forcément sans douleurs : chaque modification d'un commit risque d'entraîner des conflits dans les suivants.

- Ne vous sentez pas obliger d'avoir un historique _parfait_. Avoir un commit qui corrige un autre de la même branche n'est pas grave en soit. N'oubliez pas que plus vous jouez avec l'historique, plus vous la dénaturez, et plus vous avez de chances de casser des choses… Et casser votre historiques est une des pires choses qui puisse vous arriver : si vous supprimez une modification de l'historique, vous ne pourrez plus vous y référer plus tard (on ne peut pas `revert` ce genre de modification)

Le `git rebase` est donc une commande qui — à cause de sa grande puissance — doit être utilisée avec parcimonie.

Une manière de se protéger de ce genre de mauvaises manipulation est de sauvegardez votre état actuel (en créant une nouvelle branche) puis — après avoir effectuer vos changement — de comparer votre nouvel état à celui sauvegarder. Vous pourrez ainsi vous assurer de ne pas avoir perdu de modifications en cours de routes.

### Autosquash {#autosquash}

Prenons un exemple :

Vous êtes en train de travailler sur une fonctionnalité un peu grosse, donc vous êtes dans votre propre branche (car c'est bien évidemment un réflexe chez vous, n'est-ce pas ?) et avez déjà créé quelques commits. Soudain, vous découvrez un problème dû à l'un des premiers commits de cette branche (ne serait-ce qu'un simple commentaire non mis à jour avec le code).

Vous avez plusieurs options : le laisser tel quel (ok c'est pas la meilleure), corriger le problème dans un nouveau commit (ça peut faire sens, surtout si la correction est grosse ou un peu complexe), ou modifier le commit en question pour y inclure la correction.

Nous allons nous intéressé à ce dernier cas, et aux différentes méthodes qui permettent de réaliser la modification du commit.

Soit `<ref>` la référence du commit à corriger.

#### Méthode 1 — édition manuelle d'un commit

1. Lancez un rebase interactif
	- « `git rebase --interactive <ref>^` »
2. Demandez d'éditer le commit concerné
	- remplacez `pick` par `edit`

Cette méthode est simple à réaliser mais si vous avez des problèmes (conflits) et préférez annuler le `rebase`, alors vous perdez aussi la correction.

#### Méthode 2 — `fixup`

1. Enregistrez la correction dans un nouveau commit
	- « `git commit` »
2. Lancer un rebase interactif
	- « `git rebase --interactive <ref>^` »
3. Déplacez le commit de correction pour le placer juste en dessous du commit concerné
4. Demander de fusionner le commit de correction avec le précédent
	- remplacez `pick` par `fixup`

Cette méthode est préférable à la première, car la correction est enregistrée dans un commit : elle est sauvegardée par Git, et vous pouvez donc la manipuler comme bon vous semble (voire la garder telle quelle si vous estimez au final qu'une fusion n'est pas la meilleure solution).

#### Méthode 3 — `autosquash`

Nous allons ici faire la même chose que la méthode 2, à ceci près que nous allons utiliser les aides fournies par Git.

1. Enregistrez la correction dans un nouveau commit, dont le nom est « `fixup! <nom du nommit à corriger>` »
	- « `git commit -m 'fixup! ...'` »
	- Vous pouvez aussi utiliser « `squash!` » à la place de « `fixup!` »
2. Lancer un rebase interactif avec l'option « `autosquash` »
	- « `git rebase --interactive --autosquash <ref>^` »

L'option `--autosquash` a demandée à Git de placer le commit de correction au bon endroit, et a automatiquement demandé la fusion (en remplaçant `pick` par `fixup` ou `squash`).

Cela vous permet donc de ne pas avoir à bidouiller manuellement le fichier ouvert par Git.

#### Méthode 4 — `commit --fixup`

Nouvelle aide : l'option « `fixup` » de `git commit`.

1. Enregistrez la correction dans un nouveau commit de fix
	- « `git commit --fixup <ref>` »
	- Vous pouvez aussi utiliser `--squash`
2. Lancer un rebase interactif avec l'option « `autosquash` »
	- « `git rebase --interactive --autosquash <ref>^` »

L'option `--fixup` (respectivement `--squash`) a demandée à Git de spécifier le bon nom de commit, commençant donc par « `fixup!` » (respectivement « `squash!` »)

Cette méthode est donc plus simple (seulement 2 appels) et limite le risque d'erreur, car laisse Git faire le boulot ingrat… Sympa non ?

### Aplatir l'historique… ou pas

La commande `git rebase` saute les commits de merge par défaut. Elle aplatit donc l'historique, ce qui n'est pas toujours ce que l'on souhaite.

Sachez donc qu'il existe une option `--preserve-merges` (ou `-p`) qui change ce comportement.

Posez-vous quand même des questions si vous avez besoin de l'utiliser (est-ce vraiment une bonne chose de faire un `rebase` ?), mais si c'est le cas, cette option est vraiment pratique.  

## Git gibs

Git est un projet très intéressant : il est basé sur un modèle simple, et fourni plein d'outils pour manipuler celui-ci avec facilité.

Encore une fois, il existe plein de documentations sur le sujet, donc je ne vais tout ré-expliquer ici. Cependant, je vais vous faire un micro-résumé parce que ça me fait plaisir (j'insiste).

### Infos utiles

Pour commencer, gros changement depuis SCCS : **Git stocke des états, pas des changements**. Cela veut dire qu'il stocke tous les fichiers de chaque commit, dans leur intégralité, permettant donc d'y accéder facilement à n'importe quel moment. N'ayez pas pour autant peur d'un gâchis d'espace : grâce à son modèle (et à un peu de triche) il parvient à maintenir des tailles de dépôts comparable (souvent inférieure) à celles des _dossiers de travail_ Subversion ! Bien entendu, s'il on compare un dépôt Git et un _dépôt_ Subversion, la différence est encore plus frappante.

Autre point qu'il est bon de le savoir : tous les objets manipulés par Git sont référencés par leur SHA1, soit un _hash_ cryptographique. Il est donc (quasiment) impossible de remplacer un contenu par un autre. De plus il est possible de signer (cryptographiquement) les tags de Git. Exemple concret : les serveurs de Linux ont été pénétrés en septembre 2011, et donc les attaquants ont eu accès au dépôt principal de l'OS. Grâce à ce mécanisme sécurisé, nous savons qu'_aucune altération du dépôt n'a pu être effectuée_. Ils auraient pu (dans le pire des cas) supprimer des informations. Mais — étant donné que Git est décentralisé — tout était déjà copier dans les autres dépôts (ne serait-ce que sur le PC perso de Linus), donc là encore aucune perte possible. Donc Git est sécurisé de part son modèle… ce qui est tout de même rassurant :-)

### Les objets

Je vais donc vous parler des objets constituant le modèle de Git : `blob`, `tree`, `commit` et `tag`.

Tous les objets sont stockés de la même manière : gzippé dans un fichier nommé par la somme SHA1 du contenu (non compressé). Vous pouvez jeter un coup d'œil si le cœur vous en dit : leur chemin de fichier est de la forme `$GIT_DIR/objects/aa/bbbb`, où `aa` représente les deux premiers caractères du SHA1, et `bbb` les trente autres.

- `blob`
:	Un `blob` est juste un contenu de fichier. Git calcule la somme SHA1 de ce contenu et s'en sert pour nommer le fichier dans lequel il stocke le `blob`, gzippé. Toutes les versions de tous les fichiers commité dans votre projet se trouvent dans le dépôt local sous forme de `blob`. Étant donné que seul le contenu est pris en compte, il même `blog` peut être utilisé pour représenté plusieurs fichiers, du moment que ceux-ci ont exactement le même contenu. C'est ainsi qu'un fichier non modifié par un commit réutilisera le même blob que son commit parent. 

- `tree`
:	De même qu'un `blob` est la représentation d'un (contenu de) fichier, le `tree` est la représentation d'un dossier. Pour faire simple, c'est un fichier dans lequel Git stocke des tuples (sha1, droits, nom). De même que pour le `blob`, seul le contenu du dossier est sauvegardé, par son propre nom (ni ses propres attributs) : il pourra donc être réutilisé par les prochain commits.

- `commit`
:	La représentation d'un commit (en plus il a le même nom, c'est fou non ?). Il contient les méta-données (date, nom et email de l'auteur — qui a créé le commit — ainsi que du commiteur — qui l'a commité en dernier via un `cherry-pick`, `rebase`, `commit --amend` ou autre), les références des `commit`s parents, une référence de `tree` et le message. Ainsi que je le disais, un `commit` contient donc un _état_ et non juste un _diff_.

Ces 3 objets suffisent à représenter votre historique. Cependant, d'autres ont été ajouté pour ajouter des fonctionnalités sympathiques.

- `tag`
:	Présents depuis la première version. Il contient des méta-données (date, nom et email de l'auteur), un référence de `commit`, un message et optionnellement une signature cryptographique.

- `note`
:	Les notes sont des sortes d'extensions des messages de commits. Leur intérêt est de pouvoir être ajoutées et modifiées sans toucher au commit lui-même (donc sans modifier l'historique).

### Les références

Une référence est une string servant à désigner un objet (le plus souvant un commit).

Git est assez flexible sur les référence : elle peuvent être globales (SHA1, un nom de branche ou de tag, etc) ou relatives (parent d'un SHA1 ou d'une branche, etc).

La référence la plus connue est sans nul doute « `master` », qui est le nom de la branche créée par défaut par Git. Ensuite vient « `origin/master` » qui est la branche _remote_.

Concernant les noms de branche ou tags, leur vraie forme est « `refs/heads/master` » pour les branches locales, « `refs/remotes/origin/master` » pour les branches distantes et « `refs/tags/1.0` » pour les tags. Mais Git vous permet de ne pas écrire le « `refs/` » ni « `heads/` » ou « `tags/` ». Cependant sachez que vous pouvez utiliser la forme complête pour éviter les ambiguïtés.

Pourquoi cette forme étrange (« `refs/heads/master` » et non « `master` » tout simplement) ? La réponse est simple : c'est le chemin du fichier dans lequel Git stocke la référence. (Là je m'attends à un « Heeeeiiiiing ? »). Je reprends : votre sacro-sainte branche `master` n'est qu'un fichier dont le chemin est `$GIT_DIR/refs/heads/master` et qui contient un SHA1 (celui du commit sur lequel la branche pointe). Vous pouvez modifier le SHA1 à la main dans ce fichier : cela modifiera votre branche (à la manière d'un `git reset --soft`).

Les références relatives utilisent une syntaxe décrite dans le manuel ([git help rev-parse](http://git-scm.com/docs/git-rev-parse)), donc je ne vais pas toutes les reprendre. Cependant voici un aperçu :

`<ref>@(<date>)`
:	remonte l'historique de `<ref>` pour trouver le commit avec la date voulu (accepte des dates globales et relatives).

`<ref>^` ou `<ref>^1` ou `<ref>~1`
:	1er parent de `<ref>`

`<ref>^2`
:	2e parent de `<ref>` (donc `<ref>` est un merge)

`<ref>~2` ou `<res>^1^1`
:	1er parent du 1er parent de `<ref>`

`:/<text>`
:	remonte l'histoire pour trouver le commit donc le message contient `<text>`

Et j'en passe une belle flopée :-)

En plus de ces références _statiques_ [^statiques], Git fourni quelques références magiques, dont la valeur dépendra du contexte. Encore une fois, ce sont de simples fichiers stockés tels quels dans le dossier `$DIR_DIR`, et qui contiennent une référence. En voici quelques un :

`HEAD`
:	le commit courant. Le plus utile. Exemple d'utilisation : `HEAD~1` désigne le commit parent.

`ORIG_HEAD`
:	l'ancien commit courant. Dit comme ça c'est étrange mais en fait c'est tout à fait logique : c'est lui qui vous sauvera la vie dans le cas d'un rebase foireux. Après un rebase (ou un merge), `ORIG_HEAD` désigne le commit référencé par `HEAD` avant cette opération.

`FETCH_HEAD`
:	contient _les_ références récupérées par le dernier `fetch`. J'avoue que je vous le mets plus pour éviter de faire une liste de deux éléments, car je m'en sers relativement jamais en fait…

[^statiques]: Ça n'est pas un vrai concept de Git, surtout qu'une référence de branche évolue au cours du temps, mais je m'en fou : c'est mon article alors TGCM.

*[TGCM]: Ta Gueule C'est Magique

### Les packs

Vous vous rappelez que j'ai dit que Git ne stockait pas de diffs ? J'ai menti :-)

Stocker un objet pour chaque version de chaque fichier commité — plus les dossiers et les commits — représente un grand nombre de fichiers à créer, et la plupart des systèmes de fichiers n'aiment pas trop. De plus, même si gzip est efficace — surtout en ce qui concerne les fichiers textes — séparer les fichiers réduit les chances d'optimiser la compression.

Git stocke donc bien tous les objets décrits dans la section [Les objets](#les_objets), mais il se permet aussi d'en regrouper une (grosse) partie dans des fichiers nommés « packs ».

Un pack contient donc plusieurs objets (en fait _plein_ serait plus juste), et utilise des techniques de compression sophistiqués afin de gagner un maximum de place. Ainsi il va stocker des différentiels là où il estime que ce sera utile.

Chaque pack est constitué de 2 fichiers : le contenu et un index permettant de retrouver rapidement les objets. Ils sont stockés dans `$GIT_DIR/objects/pack`.

Les références aussi ont droit à un pack, pour celles qui ne sont pas souvent modifier : elles sont dans `$GIT_DIR/packed-refs`, qui est un fichier texte non compressé. La syntaxe est très simple : « `<sha1> <nom>` ». Il est possible d'effectuer des modifications directement dans ce fichier, elles seront prises en compte immédiatement par Git.

## Configuration {#config}

Git permet de modifier son comportement de plusieurs manières. Vous pouvez bien entendu utiliser les options de chaque commandes, mais aussi modifier la configuration de l'outil.

Il est ainsi possible de spécifier que [`pull`](#pull) doit automatiquement utiliser l'option `--rebase`, ou bien que [`push`](#push) ne peut pas être appeler sans arguments.

### Fichiers de config

La configuration peut être réparti dans plusieurs fichiers, c'est ce qui permet d'avoir des configurations spécifiques pour chaque dépôt (par exemple les infos de trackings ou les remotes).

Voici la liste des fichiers de configuration, dans l'ordre de priorité (toute variable déclarée dans un fichier écrasera celles potentiellement déclarées dans ceux décrits après).

- `$GIT_DIR/config`
:	Fichier de configuration spécifique au dépôt.

- `~/.gitconfig`
:	Fichier de configuration spécifique à l'utilisateur. Aussi nommé « global ».

- `$XDG_CONFIG_HOME/git/config`
:	Deuxième fichier de configuration spécifique à l'utilisateur. Si `$XDG_CONFIG_HOME` n'existe pas, alors `$HOME/.config/git/config` sera utilisé. [depuis Git 1.7.xx]

- `$(prefix)/etc/gitconfig`
:	Fichier de configuration système

### Git `ignore` {#gitignore}

Il existe plusieurs fichiers d'`ignore`, recensant les fichiers et dossiers que Git devrait ignorer.

Encore une fois, je ne peux que vous conseiller de lire la documentation fournie ([`git help ignore`](http://git-scm.com/docs/gitignore.html)).

Voici la liste des endroits où vous pouvez demander à Git d'ignorer certains _pattern_ (dans l'ordre de priorité — le premier étant le plus prioritaire) :

- Ligne de commande
:	Certaines commandes permettent de spécifier des fichiers à ignorer, voire de fournir un fichier contenant la liste.

- `$GIT_DIR/info/exclude`
:	Fichier existant dans chaque dépôt. Pratique pour ignorer d'éventuels scripts perso que vous utiliseriez dans un projet particulier (et donc que vous stockeriez à l'intérieur).

- Fichier spécifié par la variable de configuration `core.excludesfile`
:	Par défaut dans `$XDG_CONFIG_HOME/git/config` ou `$HOME/.config/git/config` si `$XDG_CONFIG_HOME` n'est pas défini.

Pour info, la syntaxe permet d'annuler l'ignorance de certains patterns en les préfixant par un point d'exclamation (« `!` »). Par exemple vous pouvez avoir ceci :

{% highlight text %}
 # ignore all files in data
/data
 # except the boostrap ones
!/data/boostrap
{% endhighlight %}

### Variables d'environnement

Git — à l'instar des autres commandes Unix — se réfère aux variables d'environnement pour certaines options de configuration élémentaires. Voici quelques variables utiles.

`EDITOR`
:	L'éditeur utilisé par les commandes interactives (comme `commit`, `rebase --interactive`, etc). On peut aussi le spécifier dans le fichier de configuration.

`GIT_DIR`
:	Le chemin du dossier `.git` (permet d'exécuter des commandes sans être dans le dossier)

`GIT_WORK_TREE`
:	Le chemin du *`working tree`*, c.a.d le dossier dans lequel se trouvent les fichiers pris en charge par Git.

`GIT_INDEX_FILE`
: Le chemin du fichier d'index (permet de le sauvegarder pour plus tard)

### Aliases

Le principes derrière les alias est très vieux, donc inutile de vous le présenter, je me permets cependant de vous glisser subtilement [^subtile] un petit conseil du soir, une recommandation, une idée, un concept… bref, un truc à ne pas transgresser si vous souhaitez — et vous le souhaitez — ne pas subir le châtiment divin : **ne laissez jamais un alias vous masquer la vraie commande**. Il s'agit de raccourci — pour économiser des précieuses lettres qui coûtent si cher à vos petit shell — et non de personnalisation des commandes existantes.

Par exemple, je me verrai contraint d'empaler à un poteau électrique quiconque oserait créer un alias nommé « `commit` » dont la valeur serait, par exemple, tant qu'à blasphémer autant ne pas y aller de main morte, « `commit -a` »[^contraint]. Bon, cela dit, pour cet exemple, ça ne ferait pas grand chose, Git se contenterait de l'ignorer (ouf). Il en va de même pour des « `ci=commit -a` » qui — s'il permettent de savoir qu'on parle à un alias — risquent de vous faire oublier que vous utiliser une option de la commande (et pas la meilleure de qui plus est).

Voici des exemples d'alias que je trouve pertinents, mais c'est juste pour donner une idée :

- `fetchap=fetch --all --prune` — On sait qu'on fait un fetch, et on sait qu'on ajoute des options
- `me=merge` — Plus rapide à taper que `merge`, sans pour autant changer le comportement
- `meff=merge --ff-only` — Plus rapide à taper que `merge`, et change le comportement _de manière évidente_.

Petite note pour la route : Git propose (via la config [help.autocorrect](http://git-scm.com/docs/git-config)) de corriger automatiquement vos fautes de frappe. Par exemple en appelant « `merge` » au lieu de « `merhe` ». Il va sans dire[^sansdire] qu'un grand nombre d'alias aux graphies proches risquent de nuire à cette aide. Vous voilà prévenu.

[^subtile]: Subtilement _et_ explicitement, ce qui est — il faut bien l'avouer — d'une classe assez peu représentée de nos jours. 

[^contraint]: Mais je m'emploierais néanmoins à cette tâche avec un zèle peu commun.

[^sansdire]: Heureusement je l'écris, donc ça va.

### Tracking

Je vais faire très court (parce que ça n'est pas la partie qui me fait le plus rêver) : le tracking c'est de la conf qui permet à Git savoir qu'une branche locale (disons `develop`) est liée à une branche distance (disons la branche `develop` du dépôt `origin`). C'est tout.

Configurer le tracking permet

- d'avoir des rappels sur les divergences potentielles entre ces deux branches
- d'utiliser les commandes [`git push`](#push) et [`git pull`](#pull) sans leur fournir d'arguments (à condition qu'ils soient configurés pour utiliser le tracking).

Bref : voyez le tracking comme une aide potentielle fournie par Git, mais ne tentez pas de vous reposer dessus si vous n'êtes pas sûr d'avoir la maîtrise de l'engin.

### De la bonne utilisation des éditeurs lancés par Git {#editors}

Lorsque Git lance un éditeur, il commence par créer un fichier temporaire (dans le dossier `$GIT_DIR`) puis l'ouvre avec votre éditeur favori. Il attend ensuite que l'éditeur lui rende la main puis lit le contenu du fichier et continue ce qu'il faisait.

Conséquence directe : si Git vous lance un éditeur et que vous voulez annuler la commande, alors il ne faut pas *juste* quitter. **Pour annuler il faut supprimer le contenu du fichier et sauvegarder**, ainsi Git comprendra que vous ne souhaitez plus réaliser la commande. Si vous vous contentez de quitter l'éditeur, Git interprétera cela comme « ok c'est parfait comme ça ». 

De même, il est très important que votre éditeur reste au _premier plan_. S'il s'exécute en arrière plan alors Git pensera que vous avez déjà fini… Ce qui n'est _pas exactement_ ce que vous souhaitez.

Ceci est valable pour les commandes `commit`, [`rebase -i`](#rebase-interactive), `tag`, `merge`, …
    
