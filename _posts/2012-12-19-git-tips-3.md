---
title:  Git tips — Partie 3
tagline: Le cas de git push
author: Étienne VALLETTE d'OSIA
language: French
layout: post
category : article
tags : [git]
---

# TOC
* TOC
{:toc}

{% include JB/setup %}

Tous les articles

{% assign currentDate = site.time | date: "%Y-%m-%d" %}
{% if currentDate >= "2012-12-12" %}
1. [Quelques idées sur la manière de travailler avec Git](/article/2012-12-12/git-tips-1)
{% else %}
1. Quelques idées sur la manière de travailler avec Git
{% endif %}
{% if currentDate >= "2012-12-14" %}
2. [Oubliez SVN](/article/2012-12-14/git-tips-2)
{% else %}
2. Oubliez SVN
{% endif %}
{% if currentDate >= "2012-12-19" %}
3. Le cas de git push
{% endif %}
{% if currentDate >= "2012-12-21" %}
4. [`git pull` ou `git fetch` ?](/article/2012-12-21/git-tips-4)
{% else %}
4. `git pull` ou `git fetch` ?
{% endif %}
{% if currentDate >= "2012-12-26" %}
5. [Réécrire l'histoire](/article/2012-12-26/git-tips-5)
{% else %}
5. Réécrire l'histoire
{% endif %}
{% if currentDate >= "2012-12-28" %}
6. [Git gibs](/article/2012-12-28/git-tips-6)
{% else %}
6. Git gibs
{% endif %}
{% if currentDate >= "2013-01-04" %}
7. [Configuration](/article/2013-01-04/git-tips-7)
{% else %}
7. Configuration
{% endif %}

## Partie 3 — Le cas de `git push` {#push}

`git push` est une des commandes Git utilisée quotidiennement, il convient donc de bien la connaître, pour en maîtriser la puissance et éviter les écueils.

Voici quelques conseils éviter les mauvaises surprises.

### La version longue c'est long… mais c'est bon (mais c'est long)

Tout le monde connaît le fameux « push-pull » pour se synchroniser avec le dépôt principal, mais « `git push<CR>` » n'est pas la vraie commande, c'est un raccourci.
Nous allons donc voir la vraie forme, ce qui vous permettra à la fois de mieux comprendre ce que vous faîtes… et d'utiliser les autres possibilités de cet outil.

### Oubliez « `git push --force …` »

L'option `--force` de `git push` force l'envoi de la référence, permettant d'écraser des branches distantes.

Cependant, cette option s'applique à tous les arguments de la commande.

Par exemple, je veux pousser d'un coup ma branche de développement (`feature/bla`) et la branche principale, dans laquelle j'ai ajouté un petit correctif. Si j'utilise « `git push --force origin master feature/bla` » alors je risque d'écraser la branche `master` par erreur. Dans le cas où ma branche `master` est dans un état étrange (par exemple si j'ai fait des rebases en pensant être dans ma branche de développement) alors le dépôt distant sera pollué.

Bien entendu, si j'avais utilisé « `git push --force` », j'aurais pu avoir le même résultat (cela dépend de la configuration), sauf qu'en plus je n'aurais pas su ce qui allait être pushé (à part pour ceux qui ont configuré leur Git et — le plus souvent — leur tracking en conséquence).

**Utilisez la syntaxe `+branch` à la place**, elle est plus puissante et donne plus de contrôle.

Dans mon exemple, si j'avais utilisé « `git push origin master +feature/bla` » alors seule la branche `feature/bla` aurait été poussée en force, permettant à Git de prévenir des éventuels cafouillages avec `master`.

Plus important : utiliser la syntaxe `+branch` force à nommer la branche à écraser, évidant le problème du « `git push --force <CR-oh-merde !>` ».

### Supprimez les branches distantes à l'aide « `git push <remote> :<ref>` »

Pour comprendre cette commande il faut connaître la forme complète de `git push`.

Voici un exemple : la commande « `git push origin master` » est un raccourci pour « `git push origin master:master` »[^completecomplete]. On spécifie la branche locale ainsi que la branche distante dans laquelle on pousse.

La commande « `git push <remote> :<ref>` » consiste donc à pousser _rien_ dans une branche distante… Il s'agit donc d'un effacement (à l'instar des « `mv <truc> /dev/null` » et Cie.

[^completecomplete]: Plus précisément : « `git push origin refs/heads/master:refs/heads/master` », mais on ne va pas chipotter.

### Utilisez le mode « simple » de git-push

Lorsque vous appelez `git push` sans fournir d'argument (volontairement ou non), le comportement adopté dépend de la configuration.

Voici les différents modes (actuels) :

- `nothing`
:	On ne fait rien (force à spécifier le dépôt et les références)

- `matching`
:	pousse les branches locales qui ont le même nom que des branches distantes

- `upstream`
:	pousse la branche actuelle sur sa branche trackée — Valeur par défaut de Git 1.x

- `simple`
:	pour la branche actuelle sur sa branche trackée _à condition que les deux aient le même nom_ — Ce sera le mode par défaut de Git 2.x

- `current`
:	pousse la branche actuelle sur la branche distante du même nom

Je vous conseille vivement d'opter dès maintenant pour la valeur `simple`. Pour ceci vous pouvez utiliser la commande suivante :

{% highlight bash %}
git config --global push.default simple
{% endhighlight %}

Voici un exemple d'erreur possible avec la valeur `upstream` :

{% highlight bash %}
 # Ici la branche master track la branche master du dépôt origin
git checkout master
 # On renomme master en develop, cela n'affecte pas le tracking
git branch -m develop
 # La branche develop sera poussée dans master
git push  # ⚠ ⇔ git push origin develop:master
{% endhighlight %}

J'ai parlé plusieurs fois de « tracking » dans cette section. Si vous ne savez pas ce que c'est, alors raison de plus pour utiliser le mode `simple` ! Mais ne vous en faites pas, [j'en parlerai plus tard](#tracking).
